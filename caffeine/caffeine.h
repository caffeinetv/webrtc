/*
 *  Copyright 2018 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree. An additional intellectual property rights grant can be found
 *  in the file PATENTS.  All contributing project authors may
 *  be found in the AUTHORS file in the root of the source tree.
 */

#ifndef CAFFEINE_RTC_CAFFEINE_H
#define CAFFEINE_RTC_CAFFEINE_H

#ifdef __cplusplus
extern "C" {
#else
#include <stdbool.h>
#endif

/* Log severities mapped from WebRTC library */
typedef enum {
  CAFF_LOG_SENSITIVE,
  CAFF_LOG_VERBOSE,
  CAFF_LOG_INFO,
  CAFF_LOG_WARNING,
  CAFF_LOG_ERROR,
  CAFF_LOG_NONE,
} caff_log_severity;

/* TODO: Errors generated by caffeine layer
 */
typedef enum {
  CAFF_ERROR_UNKNOWN,
} caff_error;

/* Callback type for WebRTC log messages */
typedef void (*caff_log_callback)(caff_log_severity severity,
                                  char const* message);

/* Callback types for starting broadcast */
typedef void (*caff_broadcast_started)(void* user_data);
typedef void (*caff_broadcast_failed)(void* user_data, caff_error error);

/* Opaque handles to internal objects */
struct caff_interface;
typedef struct caff_interface * caff_interface_handle;

struct caff_broadcast;
typedef struct caff_broadcast * caff_broadcast_handle;

/* Initialize the caffeine library
 *
 * log_callback: a function to call for WebRTC generated log messages
 * min_severity: sets the lowest log severity required for the callback to fire
 *
 * Returns a handle to the caffeine management object to be passed into other
 * functions. If there is an error during initialization this will be NULL
 */
caff_interface_handle caff_initialize(caff_log_callback log_callback,
                                      caff_log_severity min_severity);

/* Start broadcast on caffeine
 *
 * Sets up the WebRTC connection with Caffeine asynchronously. Calls
 * into started_callback or failed_callback with the result. This may
 * happen on a different thread than the caller.
 *
 * data: an optional pointer passed blindly to the callbacks
 * **TODO**: a broadcast details struct (name, game id, etc)
 * **TODO**: a caffeine auth struct
 * started_callback: called when broadcast successfully starts
 * failed_callback: called when broadcast fails to start
 *
 * returns a handle to the broadcast. If an error occurs before starting
 * the asynchronous operation, the handle will be NULL and the
 * failed_callback will NOT be called
 */
caff_broadcast_handle caff_start_broadcast(
    caff_interface_handle interface_handle,
    void* user_data,
    caff_broadcast_started started_callback,
    caff_broadcast_failed failed_callback);

/* TODO */
/* caff_update_screenshot(caff_broadcast_handle, some_data...) */
/* caff_update_broadcast(caff_broadcast_handle, some_data...) */
/* caff_send_video(caff_broadcast_handle, some_data...) */
/* caff_send_audio(caff_broadcast_handle, some_data...) */

/* caff_end_broadcast(caff_broadcast_handle) */


/* Deinitialize caffeine library
 *
 * This destroys the internal factory objects, releases handles to threads, etc.
 * caff_interface_handles obtained prior to this will be invalidated. Call
 * caff_initialize to use the library again.
 *
 * interface_handle: the interface handle received from caff_initialize
 */
void caff_deinitialize(caff_interface_handle interface_handle);

#ifdef __cplusplus
}
#endif

#endif /* CAFFEINE_RTC_CAFFEINE_H */
